{"version":3,"file":"audit-trail.js","sourceRoot":"","sources":["../../../../src/database/list/audit-trail.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAG/C,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAGhD,OAAO,6BAA6B,CAAC;AACrC,OAAO,kCAAkC,CAAC;AAC1C,OAAO,uBAAuB,CAAC;AAE/B,MAAM,2BAA2B,KAAoB,EAAE,UAA+B;IACpF,MAAM,CAAC,UAAC,MAAqB;QAAK,OAAA,UAAU,CAAC,SAAS,CAAC,sBAAsB,CAC3E,UAAU,CAAC,SAAS,CAAC,iBAAiB,CACpC,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,CAC1B,CACF;IAJiC,CAIjC,CAAC;CACH;AAED,MAAM,qBAAqB,KAAoB,EAAE,MAAqB;IACpE,IAAM,WAAW,GAAG,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC;SAC5C,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM,IAAK,OAAI,OAAO,SAAE,MAAM,IAAnB,CAAoB,EAAE,EAAE,CAAC,CAAC;IACvD,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;CAC1C;AAOD,oBAAoB,KAAoB;IAItC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC;SAC7B,GAAG,CAAC,UAAA,IAAI;QAEP,IAAI,aAAa,CAAC;QAElB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,KAAK;YACxB,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;SACzC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,IAAI,MAAA,EAAE,aAAa,eAAA,EAAE,CAAC;KAChC,CAAC,CAAC;CACJ;AAED,uBAAuB,KAAoB,EAAE,OAAqC;IAChF,IAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;IAClC,MAAM,CAAC,OAAO;SACX,cAAc,CAAC,OAAO,CAAC;SAGvB,GAAG,CAAC,UAAC,EAAiB;YAAhB,cAAM,EAAE,eAAO;QAEpB,IAAI,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;QAEzC,IAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,GAAG,EAAR,CAAQ,CAAC,CAAC;QACjD,MAAM,CAAC,EAAE,OAAO,SAAA,EAAE,aAAa,eAAA,EAAE,UAAU,YAAA,EAAE,CAAA;KAC9C,CAAC;SAID,SAAS,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,EAAlD,CAAkD,CAAC;SAGrE,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,OAAO,EAAZ,CAAY,CAAC,CAAC;CAC9B","sourcesContent":["import { DatabaseQuery, ChildEvent, DatabaseSnapshot, AngularFireAction, SnapshotAction } from '../interfaces';\r\nimport { stateChanges } from './state-changes';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { DataSnapshot } from '@firebase/database-types';\r\nimport { fromRef } from '../observable/fromRef';\r\nimport { AngularFireDatabase } from '../database';\r\n\r\nimport 'rxjs/add/operator/skipWhile';\r\nimport 'rxjs/add/operator/withLatestFrom';\r\nimport 'rxjs/add/operator/map';\r\n\r\nexport function createAuditTrail(query: DatabaseQuery, afDatabase: AngularFireDatabase) {\r\n  return (events?: ChildEvent[]) => afDatabase.scheduler.keepUnstableUntilFirst(\r\n    afDatabase.scheduler.runOutsideAngular(\r\n      auditTrail(query, events)\r\n    )\r\n  );\r\n}\r\n\r\nexport function auditTrail(query: DatabaseQuery, events?: ChildEvent[]): Observable<SnapshotAction[]> {\r\n  const auditTrail$ = stateChanges(query, events)\r\n    .scan((current, action) => [...current, action], []);\r\n  return waitForLoaded(query, auditTrail$);\r\n}\r\n\r\ninterface LoadedMetadata {\r\n  data: AngularFireAction<DataSnapshot>;\r\n  lastKeyToLoad: any;\r\n}\r\n\r\nfunction loadedData(query: DatabaseQuery): Observable<LoadedMetadata> {\r\n  // Create an observable of loaded values to retrieve the\r\n  // known dataset. This will allow us to know what key to\r\n  // emit the \"whole\" array at when listening for child events.\r\n  return fromRef(query, 'value')\r\n  .map(data => {\r\n    // Store the last key in the data set\r\n    let lastKeyToLoad;\r\n    // Loop through loaded dataset to find the last key\r\n    data.payload.forEach(child => {\r\n      lastKeyToLoad = child.key; return false;\r\n    });\r\n    // return data set and the current last key loaded\r\n    return { data, lastKeyToLoad };\r\n  });\r\n}\r\n\r\nfunction waitForLoaded(query: DatabaseQuery, action$: Observable<SnapshotAction[]>) {\r\n  const loaded$ = loadedData(query);\r\n  return loaded$\r\n    .withLatestFrom(action$)\r\n    // Get the latest values from the \"loaded\" and \"child\" datasets\r\n    // We can use both datasets to form an array of the latest values.\r\n    .map(([loaded, actions]) => {\r\n      // Store the last key in the data set\r\n      let lastKeyToLoad = loaded.lastKeyToLoad;\r\n      // Store all child keys loaded at this point\r\n      const loadedKeys = actions.map(snap => snap.key);\r\n      return { actions, lastKeyToLoad, loadedKeys }\r\n    })\r\n    // This is the magical part, only emit when the last load key\r\n    // in the dataset has been loaded by a child event. At this point\r\n    // we can assume the dataset is \"whole\".\r\n    .skipWhile(meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1)\r\n    // Pluck off the meta data because the user only cares\r\n    // to iterate through the snapshots\r\n    .map(meta => meta.actions);\r\n}\r\n"]}