{"version":3,"file":"collection.js","sourceRoot":"","sources":["../../../../../src/firestore/collection/collection.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentChangeType, CollectionReference, Query, DocumentReference } from '@firebase/firestore-types';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { Subscriber } from 'rxjs/Subscriber';\r\nimport { fromCollectionRef } from '../observable/fromRef';\r\nimport 'rxjs/add/operator/map';\r\nimport 'rxjs/add/operator/filter';\r\n\r\nimport { Injectable } from '@angular/core';\r\n\r\nimport { QueryFn, AssociatedReference, DocumentChangeAction } from '../interfaces';\r\nimport { docChanges, sortedChanges } from './changes';\r\nimport { AngularFirestoreDocument } from '../document/document';\r\nimport { AngularFirestore } from '../firestore';\r\n\r\nimport 'rxjs/add/observable/of';\r\n\r\nexport function validateEventsArray(events?: DocumentChangeType[]) {\r\n  if(!events || events!.length === 0) {\r\n    events = ['added', 'removed', 'modified'];\r\n  }\r\n  return events;\r\n}\r\n\r\n/**\r\n * AngularFirestoreCollection service\r\n *\r\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\r\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\r\n * is generic which gives you type safety for data update methods and data streaming.\r\n *\r\n * This class uses Symbol.observable to transform into Observable using Observable.from().\r\n *\r\n * This class is rarely used directly and should be created from the AngularFirestore service.\r\n *\r\n * Example:\r\n *\r\n * const collectionRef = firebase.firestore.collection('stocks');\r\n * const query = collectionRef.where('price', '>', '0.01');\r\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\r\n *\r\n * // NOTE!: the updates are performed on the reference not the query\r\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\r\n *\r\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\r\n * fakeStock.valueChanges().subscribe(value => console.log(value));\r\n */\r\nexport class AngularFirestoreCollection<T> {\r\n  /**\r\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\r\n   * for data operations and data streaming.\r\n   *\r\n   * Note: Data operation methods are done on the reference not the query. This means\r\n   * when you update data it is not updating data to the window of your query unless\r\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\r\n   * on this implication.\r\n   * @param ref\r\n   */\r\n  constructor(\r\n    public readonly ref: CollectionReference,\r\n    private readonly query: Query,\r\n    private readonly afs: AngularFirestore) { }\r\n\r\n  /**\r\n   * Listen to the latest change in the stream. This method returns changes\r\n   * as they occur and they are not sorted by query order. This allows you to construct\r\n   * your own data structure.\r\n   * @param events\r\n   */\r\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction[]> {\r\n    if(!events || events.length === 0) {\r\n      return this.afs.scheduler.keepUnstableUntilFirst(\r\n        this.afs.scheduler.runOutsideAngular(\r\n          docChanges(this.query)\r\n        )\r\n      );\r\n    }\r\n    return this.afs.scheduler.keepUnstableUntilFirst(\r\n        this.afs.scheduler.runOutsideAngular(\r\n          docChanges(this.query)\r\n        )\r\n      )\r\n      .map(actions => actions.filter(change => events.indexOf(change.type) > -1))\r\n      .filter(changes =>  changes.length > 0);\r\n  }\r\n\r\n  /**\r\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\r\n   * but it collects each event in an array over time.\r\n   * @param events\r\n   */\r\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction[]> {\r\n    return this.stateChanges(events).scan((current, action) => [...current, ...action], []);\r\n  }\r\n\r\n  /**\r\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\r\n   * query order.\r\n   * @param events\r\n   */\r\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction[]> {\r\n    const validatedEvents = validateEventsArray(events);\r\n    const sortedChanges$ = sortedChanges(this.query, validatedEvents);\r\n    const scheduledSortedChanges$ = this.afs.scheduler.runOutsideAngular(sortedChanges$);\r\n    return this.afs.scheduler.keepUnstableUntilFirst(scheduledSortedChanges$);\r\n  }\r\n\r\n  /**\r\n   * Listen to all documents in the collection and its possible query as an Observable.\r\n   */\r\n  valueChanges(): Observable<T[]> {\r\n    const fromCollectionRef$ = fromCollectionRef(this.query);\r\n    const scheduled$ = this.afs.scheduler.runOutsideAngular(fromCollectionRef$);\r\n    return this.afs.scheduler.keepUnstableUntilFirst(scheduled$)\r\n      .map(actions => actions.payload.docs.map(a => a.data()) as T[]);\r\n  }\r\n\r\n  /**\r\n   * Add data to a collection reference.\r\n   *\r\n   * Note: Data operation methods are done on the reference not the query. This means\r\n   * when you update data it is not updating data to the window of your query unless\r\n   * the data fits the criteria of the query.\r\n   */\r\n  add(data: T): Promise<DocumentReference> {\r\n    return this.ref.add(data);\r\n  }\r\n\r\n  /**\r\n   * Create a reference to a single document in a collection.\r\n   * @param path\r\n   */\r\n  doc<T>(path: string): AngularFirestoreDocument<T> {\r\n    return new AngularFirestoreDocument<T>(this.ref.doc(path), this.afs);\r\n  }\r\n}\r\n"]}