{"version":3,"file":"document.js","sourceRoot":"","sources":["../../../../../src/firestore/document/document.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,uBAAuB,CAAC;AAI/B,OAAO,EAAoB,cAAc,EAAE,MAAM,cAAc,CAAC;AAChE,OAAO,EAAE,0BAA0B,EAAE,MAAM,0BAA0B,CAAC;AAwBtE,MAAM;IAOJ,YAAmB,GAAsB,EAAU,GAAqB;QAArD,QAAG,GAAH,GAAG,CAAmB;QAAU,QAAG,GAAH,GAAG,CAAkB;KAAK;IAO7E,GAAG,CAAC,IAAO,EAAE,OAAoB;QAC/B,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACpC;IAMD,MAAM,CAAC,IAAgB;QACrB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KAC9B;IAKD,MAAM;QACJ,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;KAC1B;IAQD,UAAU,CAAI,IAAY,EAAE,OAAiB;QAC3C,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAChD,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QAC9D,MAAM,CAAC,IAAI,0BAA0B,CAAI,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;KAChE;IAKD,eAAe;QACb,MAAM,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACzC,MAAM,oBAAoB,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAC/E,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,sBAAsB,CAAC,oBAAoB,CAAC,CAAC;KACxE;IAKD,YAAY;QACV,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,GAAG,CAAC,MAAM;YACtC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,EAAO,GAAG,IAAI,CAAC;SAClE,CAAC,CAAC;KACJ;CACF","sourcesContent":["import { DocumentReference, SetOptions, DocumentSnapshot } from '@firebase/firestore-types';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { Subscriber } from 'rxjs/Subscriber';\r\nimport { QueryFn, AssociatedReference, Action } from '../interfaces';\r\nimport { fromDocRef } from '../observable/fromRef';\r\nimport 'rxjs/add/operator/map';\r\n\r\nimport { Injectable } from '@angular/core';\r\n\r\nimport { AngularFirestore, associateQuery } from '../firestore';\r\nimport { AngularFirestoreCollection } from '../collection/collection';\r\n\r\n/**\r\n * AngularFirestoreDocument service\r\n *\r\n * This class creates a reference to a Firestore Document. A reference is provided in\r\n * in the constructor. The class is generic which gives you type safety for data update\r\n * methods and data streaming.\r\n *\r\n * This class uses Symbol.observable to transform into Observable using Observable.from().\r\n *\r\n * This class is rarely used directly and should be created from the AngularFirestore service.\r\n *\r\n * Example:\r\n *\r\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\r\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\r\n * fakeStock.valueChanges().map(snap => {\r\n *   if(snap.exists) return snap.data();\r\n *   return null;\r\n * }).subscribe(value => console.log(value));\r\n * // OR! Transform using Observable.from() and the data is unwrapped for you\r\n * Observable.from(fakeStock).subscribe(value => console.log(value));\r\n */\r\nexport class AngularFirestoreDocument<T> {\r\n\r\n  /**\r\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\r\n   * for data operations, data streaming, and Symbol.observable.\r\n   * @param ref\r\n   */\r\n  constructor(public ref: DocumentReference, private afs: AngularFirestore) { }\r\n\r\n  /**\r\n   * Create or overwrite a single document.\r\n   * @param data\r\n   * @param options\r\n   */\r\n  set(data: T, options?: SetOptions): Promise<void> {\r\n    return this.ref.set(data, options);\r\n  }\r\n\r\n  /**\r\n   * Update some fields of a document without overwriting the entire document.\r\n   * @param data\r\n   */\r\n  update(data: Partial<T>): Promise<void> {\r\n    return this.ref.update(data);\r\n  }\r\n\r\n  /**\r\n   * Delete a document.\r\n   */\r\n  delete(): Promise<void> {\r\n    return this.ref.delete();\r\n  }\r\n\r\n  /**\r\n   * Create a reference to a sub-collection given a path and an optional query\r\n   * function.\r\n   * @param path\r\n   * @param queryFn\r\n   */\r\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T> {\r\n    const collectionRef = this.ref.collection(path);\r\n    const { ref, query } = associateQuery(collectionRef, queryFn);\r\n    return new AngularFirestoreCollection<T>(ref, query, this.afs);\r\n  }\r\n\r\n  /**\r\n   * Listen to snapshot updates from the document.\r\n   */\r\n  snapshotChanges(): Observable<Action<DocumentSnapshot>> {\r\n    const fromDocRef$ = fromDocRef(this.ref);\r\n    const scheduledFromDocRef$ = this.afs.scheduler.runOutsideAngular(fromDocRef$);\r\n    return this.afs.scheduler.keepUnstableUntilFirst(scheduledFromDocRef$);\r\n  }\r\n\r\n  /**\r\n   * Listen to unwrapped snapshot updates from the document.\r\n   */\r\n  valueChanges(): Observable<T|null> {\r\n    return this.snapshotChanges().map(action => {\r\n      return action.payload.exists ? action.payload.data() as T : null;\r\n    });\r\n  }\r\n}\r\n"]}